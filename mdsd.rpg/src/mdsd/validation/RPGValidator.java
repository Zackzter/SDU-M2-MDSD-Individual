/*
 * generated by Xtext 2.21.0
 */
package mdsd.validation;


import java.util.*;
import java.util.stream.Collectors;

import org.eclipse.emf.codegen.ecore.genmodel.GenModelPackage.Literals;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;

import mdsd.rPG.AltAttribute;
import mdsd.rPG.Attribute;
import mdsd.rPG.Attributes;
import mdsd.rPG.BEffect;
import mdsd.rPG.Buff;
import mdsd.rPG.Death;
import mdsd.rPG.Declaration;
import mdsd.rPG.Effects;
import mdsd.rPG.Entities;
import mdsd.rPG.Entity;
import mdsd.rPG.EntityAttribute;
import mdsd.rPG.EntityMoves;
import mdsd.rPG.LocalAttribute;
import mdsd.rPG.LocalTarget;
import mdsd.rPG.Locations;
import mdsd.rPG.Move;
import mdsd.rPG.MoveE;
import mdsd.rPG.Moves;
import mdsd.rPG.RPGPackage;
import mdsd.rPG.Relations;
import mdsd.rPG.Speed;
import mdsd.rPG.SystemRPG;
import mdsd.rPG.Target;
import mdsd.rPG.Teams;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RPGValidator extends AbstractRPGValidator {
	
	public static final String INVALID_NAME = "invalidName";
	public static final String UNSUPPORTED_OPERATION = "unsupportedOperation";
	public static final String MISSING_DECLARATION = "missingDeclaration";
	public static final String DUPLICATED_DECLARATION = "duplicatedDeclaration";
	public static final String EMPTY_ENTTIY_ATTRIBUTES = "emptyEntityAttributes";
	public static final String INCORRECT_TEAM_COUNT = "incorrectTeamCount";
	public static final String INDISTINCT_ATTRIBUTES = "indistinctAttributes";
	public static final String DUPLICATE_ATTRIBUTES = "duplicateLocalGlobalAttributes";
	public static final String INCORRECT_BATTLE_SIZE = "incorrectBattleSize";
	public static final String LOCAL_OTHER_ENTITY = "localNotFound";
	public static final String SPEED_ATTRIBUTE_ON_ENTITY = "speedAttributeNotAsserted";
	public static final String MISSING_ATTRIBUTE = "missingAttribute";
	public static final String DUPLICATE_ATTRIBUTE_NAME = "duplicateGlobalAttributes";


//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					RPGPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
	@Check
	public void checkEntityStartsWithCapital(Entity entity) {
		if (!Character.isUpperCase(entity.getName().charAt(0))) {
			warning("The name of an entity should be a capital letter.",  RPGPackage.Literals.ENTITY__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkGameStartsWithCapital(SystemRPG sysrpg) {
		if (!Character.isUpperCase(sysrpg.getName().charAt(0))) {
			error("The name of the game should start with a capital letter.",  RPGPackage.Literals.SYSTEM_RPG__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkEffectStartsWithCapital(Buff buff) {
		if (!Character.isUpperCase(buff.getName().charAt(0))) {
			error("The name of this effect should start with a capital letter.",  RPGPackage.Literals.EFFECT__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkEffectStartsWithCapital(MoveE buff) {
		if (!Character.isUpperCase(buff.getName().charAt(0))) {
			error("The name of this effect should start with a capital letter.",  RPGPackage.Literals.EFFECT__NAME, INVALID_NAME);
		}
	}
	
	
	
	@Check
	public void checkAttribute(Attribute att) {

		if(att.getAVal().getLTypes() == null) {
			warning("This is currently not supported in the language. Please use Float or Integer instead.", RPGPackage.Literals.ATTRIBUTE__NAME, UNSUPPORTED_OPERATION);
		}
	}
	
	private Map<String, Boolean> setupBooleanDeclarationMap() {
		Map<String, Boolean> mappy = new HashMap<String, Boolean>();
		
		mappy.put("Location", false);
		mappy.put("Relations", false);
		mappy.put("Moves", false);
		mappy.put("Entities", false);
		mappy.put("Teams", false);
		mappy.put("Death", false);
		mappy.put("Attributes", false);
		mappy.put("Effects", false);
		
		return mappy;
	}
	
	private Map<String, Integer> setupIntegerDeclarationMap() {
		Map<String, Integer> mappy = new HashMap<String, Integer>();
		
		mappy.put("Location", 0);
		mappy.put("Relations", 0);
		mappy.put("Moves", 0);
		mappy.put("Entities", 0);
		mappy.put("Teams", 0);
		mappy.put("Death", 0);
		mappy.put("Attributes", 0);
		mappy.put("Effects", 0);
		
		return mappy;
	}
	
	@Check
	public void checkDeclarations(SystemRPG sysrpg) {
		// Locations | Relations | Moves | Entities | Teams | Death | Attributes | Effects
		
		Map<String, Boolean> mappy = setupBooleanDeclarationMap();
		
		for(Declaration d : sysrpg.getDeclarations()) {

			if(d instanceof Locations) {
				mappy.computeIfPresent("Location", (k, v) -> true);
			} else if(d instanceof Relations) {
				mappy.computeIfPresent("Relations", (k, v) -> true);
			} else if(d instanceof Moves) {
				mappy.computeIfPresent("Moves", (k, v) -> true);
			} else if(d instanceof Entities) {
				mappy.computeIfPresent("Entities", (k, v) -> true);
			} else if(d instanceof Teams) {
				mappy.computeIfPresent("Teams", (k, v) -> true);
			} else if(d instanceof Death) {
				mappy.computeIfPresent("Death", (k, v) -> true);
			} else if(d instanceof Attributes) {
				mappy.computeIfPresent("Attributes", (k, v) -> true);
			} else if(d instanceof Effects) {
				mappy.computeIfPresent("Effects", (k, v) -> true);
			}			
			
		}
		
		Map<String, Boolean> notPresent = mappy.entrySet().stream()
                .filter(map -> map.getValue() == false)
                .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));
		
		String missing = "";
		for(Map.Entry<String, Boolean> entry : notPresent.entrySet()) {
			missing += " " + "[" +entry.getKey() + "]";
		}
		
		if(notPresent.size() > 0) {
			error("The following declarations are missing:" + missing + ". Please use them in your language.", RPGPackage.Literals.SYSTEM_RPG__NAME, MISSING_DECLARATION);
		}
			


	}
	
	@Check
	public void checkDuplicateDeclarations(SystemRPG sysrpg) {
		
		Map<String, Integer> mappy = setupIntegerDeclarationMap();
		
		for(Declaration d : sysrpg.getDeclarations()) {

			if(d instanceof Locations) {
				mappy.computeIfPresent("Location", (k, v) -> v+=1);
			} else if(d instanceof Relations) {
				mappy.computeIfPresent("Relations", (k, v) -> v+=1);
			} else if(d instanceof Moves) {
				mappy.computeIfPresent("Moves", (k, v) -> v+=1);
			} else if(d instanceof Entities) {
				mappy.computeIfPresent("Entities", (k, v) -> v+=1);
			} else if(d instanceof Teams) {
				mappy.computeIfPresent("Teams", (k, v) -> v+=1);
			} else if(d instanceof Death) {
				mappy.computeIfPresent("Death", (k, v) -> v+=1);
			} else if(d instanceof Attributes) {
				mappy.computeIfPresent("Attributes", (k, v) -> v+=1);
			} else if(d instanceof Effects) {
				mappy.computeIfPresent("Effects", (k, v) -> v+=1);
			}			
			
		}
		
		Map<String, Integer> notPresent = mappy.entrySet().stream()
                .filter(map -> map.getValue() > 1)
                .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));
		
		String missing = "";
		for(Map.Entry<String, Integer> entry : notPresent.entrySet()) {
			missing += " " + "[" +entry.getKey() + "]";
		}
		
		if(notPresent.size() > 0) {
			error("The following declarations are duplicated:" + missing + ". Please only use one of each.", RPGPackage.Literals.SYSTEM_RPG__NAME, MISSING_DECLARATION);
		}
		
		
		
	}
	
	@Check
	public void checkTeamSize(Teams teams) {
		if(teams.getTeam().size() < 2) {
			warning("There is currently only one team, you will instantly win with no opponents.", RPGPackage.Literals.TEAMS__TEAM, INCORRECT_TEAM_COUNT);
		}
	}
	
	@Check
	public void checkBattleSize(Teams teams) {
		if(teams.getSize().getValue() < 1) {
			error("The battle size should at least be one.", RPGPackage.Literals.TEAMS__SIZE, INCORRECT_BATTLE_SIZE);
		}
	}
	
	@Check
	public void checkDuplicateAttributesGloabalLocal(SystemRPG sysrpg) {
		List<String> existingAttributes = new ArrayList<>();
		HashSet<String> entityAttributes = new HashSet<>();
		
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Attributes) {
				existingAttributes = getGlobalAttributes((Attributes) dec);
			}
			
			else if (dec instanceof Entities) {
				for(Entity ent : ((Entities) dec).getEntity()) {
					for(EntityAttribute ea : ent.getAttributes()) {
						if(ea instanceof LocalAttribute) {
							entityAttributes.add(((LocalAttribute) ea).getName());
						}
					}
				}
			}
		}
		
		for(String s : existingAttributes) {
			for(String d : entityAttributes) {
				if(s.equals(d)) {
					error("Duplicate attribute found for local and global attribute: " + d,
							RPGPackage.Literals.SYSTEM_RPG__NAME, DUPLICATE_ATTRIBUTES);
				}
			}
		}		
	}
	
	@Check
	public void checkMissingAttribute(SystemRPG sysrpg) {		
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Entities) {
				for(Entity ent : ((Entities) dec).getEntity()) {

					List<String> entityAttributes = new ArrayList<>(); // rename					
					for(EntityAttribute ea : ent.getAttributes()) {
						if(ea instanceof LocalAttribute) {
							entityAttributes.add(((LocalAttribute) ea).getName());
						}
						if(ea instanceof AltAttribute) {
							entityAttributes.add(((AltAttribute) ea).getAttribute().getName());
						}
					}
					
					for(Move emove : ent.getEMoves().getMove()) {
						List<String> moveAttributes = new ArrayList<>();
						for(AltAttribute attribute : emove.getAtt()) {
							moveAttributes.add(attribute.getAttribute().getName());
						}
						
						for (BEffect buff : emove.getBEffect()) {
							Set<String> variables = new HashSet<>();
							for(LocalTarget localTarget : buff.getBuffEName().getReference().getLocal()) {
								if(!moveAttributes.contains(localTarget.getAttribute().getName())) variables.add(localTarget.getAttribute().getName());
							}
							for(Target target : buff.getBuffEName().getReference().getTarget()) {
								if(!moveAttributes.contains(target.getTarget().getName())) variables.add(target.getTarget().getName());
							}
							
							List<String> missingAttributes = new ArrayList<>();
							for(String attributeName : variables) {
								if(!entityAttributes.contains(attributeName)) missingAttributes.add(attributeName);

							}
							if(!missingAttributes.isEmpty())
								error(ent.getName() + " or " + emove.getName() + " are missing the attribute(s): " + missingAttributes + " to use the effect " + buff.getBuffEName().getName(),
									RPGPackage.Literals.SYSTEM_RPG__NAME, MISSING_ATTRIBUTE); //put effect name and variable name in map of set
						}
						

					}
				}
				
				
				
//				for(Entity ent : ((Entities) dec).getEntity()) {
//					if(!ent.getLocalEffects().isEmpty()) {
//						
//						for(Buff effect : ent.getLocalEffects()) {
//							for(LocalTarget lt: effect.getReference().getLocal()) {
//								
//								if(!localVariableHolder.get(ent.getName()).contains(lt.getAttribute())) {
//									for(Map.Entry<String, List<String>> entity : localVariableHolder.entrySet()) {
//										if(entity.getValue().contains(lt.getAttribute())) {
//											error("Local attribute has been found at another entity, prob make it global, entity found: " 
//													+ entity.getKey(), RPGPackage.Literals.SYSTEM_RPG__NAME, LOCAL_OTHER_ENTITY);
//										}
//									}
//								}
//							}
//						}
//					}
//				}

			}
			
		}
	}
	
//	for (Map.Entry<String,String> entry : gfg.entrySet())  
//        System.out.println("Key = " + entry.getKey() + 
//                         ", Value = " + entry.getValue()); 

	
	public Attribute getSpeedAttribute(SystemRPG sysrpg) {
		Attribute speedAttribute = null;
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Speed) {
				speedAttribute = ((Speed) dec).getSpeedValue();
			}
		}
		return speedAttribute;
	}
	
	public List<String> getGlobalAttributes(Attributes attributes){
		List<String> attributesList = new ArrayList<>();
		for(Attribute attribute : attributes.getAttribute()) {
			attributesList.add(attribute.getName());
		}
		return attributesList;
	}
	
	@Check
	public void checkSpeedAttribute(SystemRPG sysrpg) {
		Attribute speedAttribute = getSpeedAttribute(sysrpg);
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Entities) {
				for(Entity entity : ((Entities) dec).getEntity()) {
					boolean hasSpeedAttribute = false;
					for(EntityAttribute attribute : entity.getAttributes()) {
						if(attribute instanceof AltAttribute) {
							if(((AltAttribute) attribute).getAttribute().getName().equals(speedAttribute.getName())) hasSpeedAttribute = true;
						}
					}
					if(!hasSpeedAttribute) warning( entity.getName() + " does not have the speed attribute: " + 
							speedAttribute.getName(), RPGPackage.Literals.SYSTEM_RPG__NAME, SPEED_ATTRIBUTE_ON_ENTITY);
				}
			}
		}
	}
	
	@Check
	public void checkDuplicateGlobalAttributeName(Attributes attributes) {
		List<String> attributesList = getGlobalAttributes(attributes);
		Set<String> firstSet = new HashSet<>();
		
		for(String attribute : attributesList) {
			if(!firstSet.add(attribute)) {
				error(attribute + " has already been declared once.",
						RPGPackage.Literals.ATTRIBUTES__ATTRIBUTE, DUPLICATE_ATTRIBUTE_NAME);
			}

		}
	}
	
	
	
	@Check
	public void checkAttributesAreDistinct(SystemRPG sysrpg) {
		HashSet<String> moveAttributes = new HashSet<>();
		HashSet<String> entityAttributes = new HashSet<>();
		
		
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Moves) {
				for(Move mov : ((Moves) dec).getMove()) {
					for(AltAttribute a : mov.getAtt()) {
						moveAttributes.add(a.getAttribute().getName());
					}					
				}
			} else if(dec instanceof Entities) {
				for(Entity ent : ((Entities) dec).getEntity()) {
					for(EntityAttribute ea : ent.getAttributes()) {
						if(ea instanceof AltAttribute) {
							entityAttributes.add(((AltAttribute) ea).getAttribute().getName());
						}
					}

				}
			}
		}
		
		ArrayList<String> duplicates = new ArrayList<String>();
		
		for(String s : moveAttributes) {
			for(String d : entityAttributes) {
				if(s.equals(d)) {
					duplicates.add(d);
				}
			}
		}
		
		if(!duplicates.isEmpty()) {
			warning("Due to way the code has been implemented, using the same attribute in both an entity, and a move,"
					+ " can cause unwanted side effects, please consider changing the following duplicated attribute(s): " 
					+ duplicates, RPGPackage.Literals.SYSTEM_RPG__NAME, INDISTINCT_ATTRIBUTES);
		}
		
		
	}

	
}
