/*
 * generated by Xtext 2.21.0
 */
package mdsd.validation;


import java.util.*;
import java.util.stream.Collectors;


import org.eclipse.xtext.validation.Check;

import mdsd.rPG.AltAttribute;
import mdsd.rPG.Attribute;
import mdsd.rPG.Attributes;
import mdsd.rPG.BEffect;
import mdsd.rPG.Buff;
import mdsd.rPG.Death;
import mdsd.rPG.Declaration;
import mdsd.rPG.Effects;
import mdsd.rPG.Entities;
import mdsd.rPG.Entity;
import mdsd.rPG.EntityAttribute;
import mdsd.rPG.LocalAttribute;
import mdsd.rPG.LocalTarget;
import mdsd.rPG.Locations;
import mdsd.rPG.MEffect;
import mdsd.rPG.Move;
import mdsd.rPG.MoveE;
import mdsd.rPG.Moves;
import mdsd.rPG.RPGPackage;
import mdsd.rPG.Relations;
import mdsd.rPG.Self;
import mdsd.rPG.Speed;
import mdsd.rPG.SystemRPG;
import mdsd.rPG.Target;
import mdsd.rPG.Teams;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RPGValidator extends AbstractRPGValidator {
	
	public static final String INVALID_NAME = "invalidName";
	public static final String UNSUPPORTED_OPERATION = "unsupportedOperation";
	public static final String MISSING_DECLARATION = "missingDeclaration";
	public static final String DUPLICATED_DECLARATION = "duplicatedDeclaration";
	public static final String EMPTY_ENTTIY_ATTRIBUTES = "emptyEntityAttributes";
	public static final String INCORRECT_TEAM_COUNT = "incorrectTeamCount";
	public static final String INDISTINCT_ATTRIBUTES = "indistinctAttributes";
	public static final String DUPLICATE_ATTRIBUTES = "duplicateLocalGlobalAttributes";
	public static final String INCORRECT_BATTLE_SIZE = "incorrectBattleSize";
	public static final String SPEED_ATTRIBUTE_ON_ENTITY = "speedAttributeNotAsserted";
	public static final String MISSING_ATTRIBUTE = "missingAttribute";
	public static final String DUPLICATE_ATTRIBUTE_NAME = "duplicateGlobalAttributes";


//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					RPGPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
	@Check
	public void checkEntityStartsWithCapital(Entity entity) {
		if (!Character.isUpperCase(entity.getName().charAt(0))) {
			warning("The name of an entity should be a capital letter.",  RPGPackage.Literals.ENTITY__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkGameStartsWithCapital(SystemRPG sysrpg) {
		if (!Character.isUpperCase(sysrpg.getName().charAt(0))) {
			error("The name of the game should start with a capital letter.",  RPGPackage.Literals.SYSTEM_RPG__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkEffectStartsWithCapital(Buff buff) {
		if (!Character.isUpperCase(buff.getName().charAt(0))) {
			error("The name of this effect should start with a capital letter.",  RPGPackage.Literals.EFFECT__NAME, INVALID_NAME);
		}
	}
	
	@Check
	public void checkEffectStartsWithCapital(MoveE buff) {
		if (!Character.isUpperCase(buff.getName().charAt(0))) {
			error("The name of this effect should start with a capital letter.",  RPGPackage.Literals.EFFECT__NAME, INVALID_NAME);
		}
	}
	
	
	
	@Check
	public void checkAttribute(Attribute att) {

		if(att.getAVal().getLTypes() == null) {
			warning("This is currently not supported in the language. Please use Float or Integer instead.", RPGPackage.Literals.ATTRIBUTE__NAME, UNSUPPORTED_OPERATION);
		}
	}
	
	private Map<String, Boolean> setupBooleanDeclarationMap() {
		Map<String, Boolean> mappy = new HashMap<String, Boolean>();
		
		mappy.put("Location", false);
		mappy.put("Relations", false);
		mappy.put("Moves", false);
		mappy.put("Entities", false);
		mappy.put("Teams", false);
		mappy.put("Death", false);
		mappy.put("Speed", false);
		mappy.put("Attributes", false);
		mappy.put("Effects", false);
		
		return mappy;
	}
	
	private Map<String, Integer> setupIntegerDeclarationMap() {
		Map<String, Integer> mappy = new HashMap<String, Integer>();
		
		mappy.put("Location", 0);
		mappy.put("Relations", 0);
		mappy.put("Moves", 0);
		mappy.put("Entities", 0);
		mappy.put("Teams", 0);
		mappy.put("Death", 0);
		mappy.put("Speed", 0);
		mappy.put("Attributes", 0);
		mappy.put("Effects", 0);
		
		return mappy;
	}
	
	@Check
	public void checkDeclarations(SystemRPG sysrpg) {
		// Locations | Relations | Moves | Entities | Teams | Death | Speed | Attributes | Effects
		
		Map<String, Boolean> mappy = setupBooleanDeclarationMap();
		
		for(Declaration d : sysrpg.getDeclarations()) {

			if(d instanceof Locations) {
				mappy.computeIfPresent("Location", (k, v) -> true);
			} else if(d instanceof Relations) {
				mappy.computeIfPresent("Relations", (k, v) -> true);
			} else if(d instanceof Moves) {
				mappy.computeIfPresent("Moves", (k, v) -> true);
			} else if(d instanceof Entities) {
				mappy.computeIfPresent("Entities", (k, v) -> true);
			} else if(d instanceof Teams) {
				mappy.computeIfPresent("Teams", (k, v) -> true);
			} else if(d instanceof Death) {
				mappy.computeIfPresent("Death", (k, v) -> true);
			} else if(d instanceof Speed) {
				mappy.computeIfPresent("Speed", (k, v) -> true);
			} else if(d instanceof Attributes) {
				mappy.computeIfPresent("Attributes", (k, v) -> true);
			} else if(d instanceof Effects) {
				mappy.computeIfPresent("Effects", (k, v) -> true);
			}			
			
		}
		
		Map<String, Boolean> notPresent = mappy.entrySet().stream()
                .filter(map -> map.getValue() == false)
                .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));
		
		String missing = "";
		for(Map.Entry<String, Boolean> entry : notPresent.entrySet()) {
			missing += " " + "[" +entry.getKey() + "]";
		}
		
		if(notPresent.size() > 0) {
			error("The following declarations are missing:" + missing + ". Please use them in your language.", RPGPackage.Literals.SYSTEM_RPG__NAME, MISSING_DECLARATION);
		}
			


	}
	
	@Check
	public void checkDuplicateDeclarations(SystemRPG sysrpg) {
		
		Map<String, Integer> mappy = setupIntegerDeclarationMap();
		
		for(Declaration d : sysrpg.getDeclarations()) {

			if(d instanceof Locations) {
				mappy.computeIfPresent("Location", (k, v) -> v+=1);
			} else if(d instanceof Relations) {
				mappy.computeIfPresent("Relations", (k, v) -> v+=1);
			} else if(d instanceof Moves) {
				mappy.computeIfPresent("Moves", (k, v) -> v+=1);
			} else if(d instanceof Entities) {
				mappy.computeIfPresent("Entities", (k, v) -> v+=1);
			} else if(d instanceof Teams) {
				mappy.computeIfPresent("Teams", (k, v) -> v+=1);
			} else if(d instanceof Death) {
				mappy.computeIfPresent("Death", (k, v) -> v+=1);
			} else if (d instanceof Speed) {
				mappy.computeIfPresent("Speed", (k, v) -> v+=1);
			} else if(d instanceof Attributes) {
				mappy.computeIfPresent("Attributes", (k, v) -> v+=1);
			} else if(d instanceof Effects) {
				mappy.computeIfPresent("Effects", (k, v) -> v+=1);
			}			
			
		}
		
		Map<String, Integer> notPresent = mappy.entrySet().stream()
                .filter(map -> map.getValue() > 1)
                .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue()));
		
		String missing = "";
		for(Map.Entry<String, Integer> entry : notPresent.entrySet()) {
			missing += " " + "[" +entry.getKey() + "]";
		}
		
		if(notPresent.size() > 0) {
			error("The following declarations are duplicated:" + missing + ". Please only use one of each.", RPGPackage.Literals.SYSTEM_RPG__NAME, MISSING_DECLARATION);
		}
		
		
		
	}
	
	@Check
	public void checkTeamSize(Teams teams) {
		if(teams.getTeam().size() < 2) {
			warning("There is currently only one team, you will instantly win with no opponents.", RPGPackage.Literals.TEAMS__TEAM, INCORRECT_TEAM_COUNT);
		}
	}
	
	@Check
	public void checkBattleSize(Teams teams) {
		if(teams.getSize().getValue() < 1) {
			error("The battle size should at least be one.", RPGPackage.Literals.TEAMS__SIZE, INCORRECT_BATTLE_SIZE);
		}
	}
	
	@Check
	public void checkDuplicateAttributesGloabalLocal(SystemRPG sysrpg) {
		List<Attribute> existingAttributes = new ArrayList<>();		
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Attributes) {
				existingAttributes = getGlobalAttributes((Attributes) dec);
				break;
			}
		}
		
		for(Declaration dec : sysrpg.getDeclarations())
			if (dec instanceof Entities) {
				for(Entity ent : ((Entities) dec).getEntity()) {
					for(EntityAttribute ea : ent.getAttributes()) {
						if(ea instanceof LocalAttribute) {
							
							for(Attribute gAttribute : existingAttributes) {
								String localAttributeName = ((LocalAttribute) ea).getName();
								if(gAttribute.getName().equals(localAttributeName)) {
									error("Duplicate attribute found for local and global attribute: " + localAttributeName,
											ea, RPGPackage.Literals.LOCAL_ATTRIBUTE__NAME, DUPLICATE_ATTRIBUTES);
									error("Duplicate attribute found for local and global attribute: " + localAttributeName,
											gAttribute, RPGPackage.Literals.ATTRIBUTE__NAME, DUPLICATE_ATTRIBUTES);
								}
							}
						}
					}
				}
			}		
	}
	
	@Check
	public void checkMissingAttribute(SystemRPG sysrpg) {		
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Entities) {
				for(Entity ent : ((Entities) dec).getEntity()) {

					List<String> entityAttributes = new ArrayList<>();					
					for(EntityAttribute ea : ent.getAttributes()) {
						if(ea instanceof LocalAttribute) {
							entityAttributes.add(((LocalAttribute) ea).getName());
						}
						if(ea instanceof AltAttribute) {
							entityAttributes.add(((AltAttribute) ea).getAttribute().getName());
						}
					}
					
					for(Move emove : ent.getEMoves().getMove()) {
						List<String> moveAttributes = new ArrayList<>();
						for(AltAttribute attribute : emove.getAtt()) {
							moveAttributes.add(attribute.getAttribute().getName());
						}
						
						//change here
						for (BEffect buff : emove.getBEffect()) {
							Set<String> variables = new HashSet<>();
							for(LocalTarget localTarget : buff.getBuffEName().getReference().getLocal()) {
								if(!moveAttributes.contains(localTarget.getAttribute().getName())) variables.add(localTarget.getAttribute().getName());
							}
							for(Target target : buff.getBuffEName().getReference().getTarget()) {
								if(!moveAttributes.contains(target.getTarget().getName())) variables.add(target.getTarget().getName());
							}
							
							List<String> missingAttributes = new ArrayList<>();
							for(String attributeName : variables) {
								if(!entityAttributes.contains(attributeName)) missingAttributes.add(attributeName);

							}
							if(!missingAttributes.isEmpty())
								error(ent.getName() + " or " + emove.getName() + " are missing the attribute(s): " + missingAttributes + " to use the effect " + buff.getBuffEName().getName(),
									ent, RPGPackage.Literals.ENTITY__ATTRIBUTES, MISSING_ATTRIBUTE); //put effect name and variable name in map of set
						}
						
						for (MEffect move : emove.getMEffect()) {
							Set<String> variables = new HashSet<>();
							
							for(Self selfTarget : move.getMoveEName().getReference().getSelfT()) {
								if(!moveAttributes.contains(selfTarget.getTarget().getName())) variables.add(selfTarget.getTarget().getName());
							}
							List<String> missingAttributes = new ArrayList<>();
							for(String attributeName : variables) {
								if(!entityAttributes.contains(attributeName)) missingAttributes.add(attributeName);

							}
							if(!missingAttributes.isEmpty())
								error(ent.getName() + " or " + emove.getName() + " are missing the attribute(s): " + missingAttributes + " to use the effect " + move.getMoveEName().getName(),
									ent, RPGPackage.Literals.ENTITY__ATTRIBUTES, MISSING_ATTRIBUTE); //put effect name and variable name in map of set
						}
						

					}
				}

			}
			
		}
	}
	

	
	public Attribute getSpeedAttribute(SystemRPG sysrpg) {
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Speed) {
				return ((Speed) dec).getSpeedValue();
			}
		}
		return null;
	}
	
	public List<Attribute> getGlobalAttributes(Attributes attributes){
		List<Attribute> attributesList = new ArrayList<>();
		for(Attribute attribute : attributes.getAttribute()) {
			attributesList.add(attribute);
		}
		return attributesList;
	}
	
	@Check
	public void checkSpeedAttribute(SystemRPG sysrpg) {
		Attribute speedAttribute = getSpeedAttribute(sysrpg);
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Entities) {
				for(Entity entity : ((Entities) dec).getEntity()) {
					boolean hasSpeedAttribute = false;
					for(EntityAttribute attribute : entity.getAttributes()) {
						if(attribute instanceof AltAttribute) {
							if(((AltAttribute) attribute).getAttribute().getName().equals(speedAttribute.getName())) hasSpeedAttribute = true;
						}
					}
					if(!hasSpeedAttribute) warning( entity.getName() + " does not have the speed attribute: " + 
							speedAttribute.getName(), entity, RPGPackage.Literals.ENTITY__ATTRIBUTES, SPEED_ATTRIBUTE_ON_ENTITY);
				}
			}
		}
	}
	
	
	@Check
	public void checkDuplicateGlobalAttributeName(Attributes attributes) {
		List<Attribute> attributesList = getGlobalAttributes(attributes);
		Set<String> firstSet = new HashSet<>();
		
		for(Attribute attribute : attributesList) {
			if(!firstSet.add(attribute.getName())) {
				error(attribute.getName() + " has already been declared once.",
						attribute, RPGPackage.Literals.ATTRIBUTE__NAME, DUPLICATE_ATTRIBUTE_NAME);
			}

		}
	}
	
	
	
	@Check
	public void checkAttributesAreDistinct(SystemRPG sysrpg) {
		HashSet<AltAttribute> moveAttributes = new HashSet<>();		
		
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Moves) {
				for(Move mov : ((Moves) dec).getMove()) {
					for(AltAttribute a : mov.getAtt()) {
						moveAttributes.add(a);
					}					
				}
			}
		}
		
		for(Declaration dec : sysrpg.getDeclarations()) {
			if(dec instanceof Entities) {
				for(Entity ent : ((Entities) dec).getEntity()) {
					for(EntityAttribute ea : ent.getAttributes()) {
						if(ea instanceof AltAttribute) {
							String entityAttributeName = ((AltAttribute) ea).getAttribute().getName();
							for(AltAttribute moveAttribute : moveAttributes) {
								if(moveAttribute.getAttribute().getName().equals(entityAttributeName)) {
									warning("Due to way the code has been implemented, using the same attribute in both an entity, and a move,"
											+ " can cause unwanted side effects, please consider changing  " 
											+ entityAttributeName, ea, RPGPackage.Literals.ALT_ATTRIBUTE__ATTRIBUTE, INDISTINCT_ATTRIBUTES);
									warning("Due to way the code has been implemented, using the same attribute in both an entity, and a move,"
											+ " can cause unwanted side effects, please consider changing  " 
											+ entityAttributeName, moveAttribute, RPGPackage.Literals.ALT_ATTRIBUTE__ATTRIBUTE, INDISTINCT_ATTRIBUTES);
								}
							}
						}
					}
				}
			}
		}
	}
}

	
